{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Salt Tower \u2014 A Flexible External Pillar Module","text":"<p>Salt Tower is an advanced and flexible external pillar module that gives access to pillar values while processing and merging them, can render all usual salt file formats and include private and binary files for a minion.</p> <p>Salt Tower is inspired by pillarstack for merging pillar files and giving access to them. It also has a top file like salt itself and utilizes salt renderers to supports all formats such as YAML, JINJA, Python and any combination. Supercharged renderers for plain text and YAML are included too.</p> <p>Each tower data file is passed the current processed pillars. They can therefore access previously defined values. Data files can include other files that are all merged together.</p> <p>Salt Tower is designed to completely replace the usual pillar repository or can be utilized beside salts original pillar that e.g. can bootstrap a salt master with Salt Tower.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Salt Tower is set up and configured in the salt master configuration. See salts <code>ext_pillar</code> documentation for details about external pillar modules.</p> <p>The <code>tower</code> external pillar modules only needs one or more tower files for configuration:</p> <pre><code># /etc/salt/master.d/tower.conf\n\next_pillar:\n  - tower: /path/to/tower.sls\n</code></pre>"},{"location":"configuration/#feature-flags","title":"Feature flags","text":"<p>Salt Tower behavior can be twisted a bit using feature flags. They can be set in the salt master configuration file.</p>"},{"location":"configuration/#include_directory_mode","title":"include_directory_mode","text":"<p>The <code>include_directory_mode</code> flag changes the behavior when including files from a directory. The default mode <code>\"init\"</code> works just like expected.</p> <p>When including a file such as <code>role/openssh</code>, Salt Tower will look for the following files and pick the first one that exists:</p> <ol> <li><code>role/openssh</code></li> <li><code>role/openssh.sls</code></li> <li><code>role/openssh/init.sls</code></li> </ol> <p>An alternative mode can be enabled by setting <code>include_directory_mode</code> to <code>\"all-sls\"</code>:</p> <pre><code># /etc/salt/master\n\nsalt_tower.include_directory_mode: all-sls\n</code></pre> <p>Salt Tower will now look if <code>role/openssh</code> is a directory. If that is the case, it will include all <code>*.sls</code> files in that directory, ordered by filename:</p> <ol> <li><code>role/openssh/10-config.sls</code></li> <li><code>role/openssh/20-ciphers.sls</code></li> </ol> <p>When no files are found in that directory, it will proceed with the same lookup roles as before.</p> <p>The <code>all-sls</code> mode can be quite useful if you like to split up e.g. your roles, or minion overrides into multiple, ordered files, for example to use different renderers.</p> <p>Example</p> <p>Imagine you want to configure <code>openssh</code> for your servers and you want to ship distribution specific settings for e.g. allowed ciphers. Servers running <code>openssh</code> are currently including <code>role/openssh</code>, that contains the shared config, and you do not want to add role details to your <code>tower.sls</code>, or update the include statement for each server.</p> <p>Using the <code>salt_tower.include_directory_mode: all-sls</code> mode, you can simply replace your <code>role/openssh.sls</code> or <code>role/openssh/init.sls</code> with a directory, and, for example, use the <code>filter</code> renderer to only add the specific bits needed:</p> role/openssh/10-config.sls<pre><code># Shared config for all openssh daemons\n\nopenssh:\n  server:\n    config:\n      Port: 22\n      Protocol: 2\n      HostKey: [/etc/ssh/ssh_host_ed25519_key]\n      # ...\n</code></pre> role/openssh/11-ciphers.sls<pre><code># yaml | filter grain=oscodename\n\n# Restrict key exchange, cipher, and MAC algorithms, as per sshaudit.com\n# hardening guide.\n\nbionic: # Ubuntu 18.04\n  openssh:\n    server:\n      config:\n        Ciphers: chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n        HostKeyAlgorithms: ssh-ed25519,ssh-ed25519-cert-v01@openssh.com\n        KexAlgorithms: curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256\n        MACs: hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\n\nfocal: # Ubuntu 20.04\n  openssh:\n    server:\n      config:\n        Ciphers: chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n        HostKeyAlgorithms: ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,sk-ssh-ed25519@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512,rsa-sha2-256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com\n        KexAlgorithms: curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256\n        MACs: hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\n</code></pre> <p>The servers will now a all share the same configuration, but will have different cipher settings depending on their operating system version.</p>"},{"location":"configuration/#salt_towerraise_on_missing_files","title":"salt_tower.raise_on_missing_files","text":"<p>Enabling the <code>salt_tower.raise_on_missing_files</code> flag will have salt tower raise an error if any included file from <code>tower.sls</code> or any <code>include</code> list cannot be found. If the include statement is a pattern, that does not match any files, an error will be raised too.</p> <p>Includes in the top <code>tower.sls</code> can be marked as optional using the special <code>!optional</code> YAML tag:</p> tower.sls<pre><code>base:\n  - common/*\n\n  # Optional minion-specific overrides\n  - !optional minion/{{ minion_id }}\n</code></pre>"},{"location":"configuration/#salt_towerunstable_enable_saltenv","title":"salt_tower.unstable_enable_saltenv","text":"<p>The <code>salt_tower.unstable_enable_saltenv</code> flag modifies some options passed to the salt rendering pipeline. The salt renderers behave differently if they think they are rendering a state file or a pillar file. Including a file, such as with JINJA <code>import_yaml</code> will look up files in either <code>file_roots</code> or <code>pillar_roots</code>. Unfortunately, this behavior cannot be customized by plugins.</p> <p>By setting <code>salt_tower.unstable_enable_saltenv</code> to <code>True</code>, Salt Tower will pass additional flags to the rendering pipeline, indicating that pillars are rendered. Engines, such as JINJA, will now look up files in <code>pillar_roots</code>. This can work well, when you Salt Tower base directory is the same as the pillar root directory.</p> <p>See issue #11 for more details.</p>"},{"location":"configuration/#salt_towerenable_inventory","title":"salt_tower.enable_inventory","text":"<p>Experimental feature: Enables the <code>inventory</code> mode. All pillar data within the <code>inventory:</code> subtree will not be returned in the final result. Instead, an additional context module is passed to templates, easing access to minion-scoped variables.</p> <p>This inventory can be used to provide specialized, independent variable values to other pillar files such as roles. See the following example:</p> tower.sls<pre><code>base:\n  - inventory/*\n  - 'web*'\n      - role/web\n</code></pre> inventory/vars.sls<pre><code>inventory:\n  web-0:\n    ip:\n      public: 203.0.113.100\n    nginx:\n      server_name: example.org\n\n  web-1:\n    ip:\n      public: 203.0.113.110\n    nginx:\n      server_name: example.com\n</code></pre> role/web.sls<pre><code>states:\n  - nginx\n\nnginx:\n  config: |\n    server {\n      listen {{ inventory.get('ip:public') }}:80;\n      server_name {{ inventory.get('nginx:server_name') }};\n    }\n</code></pre> <p>The inventory can provide custom variables to be used in larger pillar files, or used in multiple roles.</p>"},{"location":"installation/","title":"Installation","text":"<p>Salt Tower needs to be installed on the salt master to be available as an <code>ext_pillar</code> module.</p> <p>The recommended installation methods are either via salts gitfs backend or with Pythons package manager <code>pip</code>.</p>"},{"location":"installation/#salt-gitfs","title":"Salt GitFS","text":"<p>This method utilizes salts gitfs backend to directly load the tower module and renderers from this git repository. Ensure to follow the gitfs setup guide.</p> <p>Add the following to you salt master configuration, e.g. <code>/etc/salt/master.d/tower.conf</code>. It is recommended to pin to a specific version or commit, to avoid unexpected updates and because you need to sync all modules after any change.</p> <pre><code>gitfs_remotes:\n  - https://github.com/jgraichen/salt-tower.git:\n      - base: v1.7.0\n</code></pre> <p>You need to sync all salt modules after installation and any upgrade:</p> <pre><code>$ salt-run saltutil.sync_all\npillar:\n    - pillar.tower\nrenderers:\n    - renderers.filter\n    - renderers.text\n    - renderers.yamlet\n</code></pre> <p>This will make all modules (e.g. renderers) available to all minions too.</p> <p>Warning</p> <p>All content from this repository will be \"loaded\" into your states tree, including any files from e.g. <code>test/</code>, <code>examples/</code>, <code>docs/</code> or the root directory.</p>"},{"location":"installation/#pip-python-package","title":"PIP Python Package","text":"<p>Salt Tower can be installed via the <code>pip</code> Python package manager too:</p> <pre><code>$ pip install salt-tower\n</code></pre> <p>This will install Salt Tower as a Python package on the system, which is loaded by the salt processes.</p> <p>Warning</p> <p>The tower modules (e.g. renderers) will only be available on the salt master or minion where the <code>salt-tower</code> package is installed. They are not automatically synced to any minion.</p>"},{"location":"pillar/","title":"Pillar Data Files","text":"<p>Pillar data files define the actual pillar data that is loaded and merged by salt tower. Data files are rendered using the available salt renderers, therefore all usual features are available. The default renderers are <code>jinja|yamlet</code>, if no shebang is specified.</p>"},{"location":"pillar/#example","title":"Example","text":"<pre><code>include:\n  - shared/wordpress\n\nstates:\n  - nginx\n  - php-fpm\n\nnginx:\n  package: nginx-light\n\n  sites:\n    blog: !include files/nginx.blog.j2\n{% if grains[\"oscodename\"] == \"bionic\" %}\n    default: !read files/nginx.default-override.conf\n{% endif %}\n\nwordpress:\n  config:\n    title: Blog for {{ tower.get(\"site:customer_name\") }}\n</code></pre>"},{"location":"tower/","title":"Tower File","text":"<p>The tower files works similar to the regular <code>top.sls</code>. It defines rules which files shall be loaded for a minion, based on e.g. the minion ID, grains, or pillar values.</p>"},{"location":"tower/#example","title":"Example","text":"<pre><code>base:  # salt environment\n\n  # Load common pillar data files for all minions.\n  - common/*.sls\n\n  # Use JINJA to load some pillar data files based on\n  # some grains, e.g. operating system.\n  - dist/{{ grains[\"oscodename\"] }}/*.sls\n\n  # Match a minion by ID\n  - \"*.example.org\":\n\n      # Include a pillar data file for this minion. Path is\n      # relative to the tower.sls.\n      - roles/example.sls\n\n      # Directly set some pillar values without loading\n      # an extra file first.\n      - site:\n          domain: example.org\n\n  # Match a previously set pillar value\n  - \"I@site:domain:example.org\":\n      - site/example/*.sls\n</code></pre>"},{"location":"renderers/","title":"Renderers","text":"<p>Salt-tower ships multiple renderers to ease working with complex pillars and organizaing data.</p>"},{"location":"renderers/#yamlet","title":"Yamlet","text":"<p>The Yamlet renderer is a supercharged YAML renderer that supports including additional files, template or binary files, in a safe and easy manner.</p> <p>This can help with</p> <ul> <li> <p>shipping configuration files or snippet, license blobs, private files such as TLS keys, securely from the pillar to minions,</p> </li> <li> <p>sharing templates on the master to ship ready to use config files to minions,</p> </li> <li> <p>organize and share pillar data between minions,</p> </li> <li> <p>working with complex setups, such as multiple customers and brands,</p> </li> <li> <p>writing simpler states by just dropping config files blobs instead of thousand lines of JINJA macros.</p> </li> </ul>"},{"location":"renderers/#filter","title":"Filter","text":"<p>The filter renderer returns a subset of its data matching grains or pillar keys. This eases organizing data and reusing datasets for multiple minions, roles or any common pillar file.</p>"},{"location":"renderers/#text","title":"Text","text":"<p>The text renderer is a renderer mostly needed in conjunction with the Yamlet renderer when loading and including templates.</p>"},{"location":"renderers/filter/","title":"Filter","text":"<p>The <code>filter</code> renderer takes a data structure, e.g. from the Yamlet renderer, applies some filter based on the top-level keys and returns the first matching item.</p>"},{"location":"renderers/filter/#example","title":"Example","text":"<p>By default, the <code>filter</code> renderer will match top-level keys with the salt minion ID from grains, but any grain can be specified:</p>"},{"location":"renderers/filter/#minion-id","title":"Minion ID","text":"<pre><code>#!yaml|filter grain=id\nweb_*:\n  roles:\n    - webserver\n\ndb_*:\n  roles:\n    - database\n\nsalt:\n  roles:\n    - salt/master\n\n*.example.org:\n  roles:\n    - app\n</code></pre> <p>This example matches each top-level key with the <code>id</code> grain (the minion ID) and only returns the first matching data:</p> <pre><code># minion: web_03.example.org\nroles:\n  - webserver\n\n# minion: db_a.example.org\nroles:\n  - database\n\n# minion: blog.example.org\nroles:\n  - app\n</code></pre>"},{"location":"renderers/filter/#match-a-grain","title":"Match a grain","text":"<p>The renderer can use any grain to match top-level keys:</p> <pre><code>#!yaml | filter grain=os_family\nDebian:\n  repo_url: http://apt.example.org\n\nRedHat:\n  repo_url: http://rpm.example.org\n</code></pre>"},{"location":"renderers/filter/#match-a-pillar-key","title":"Match a pillar key","text":"<p>The <code>filter</code> renderer can match on a previously set pillar key too.</p> <p>In this example the generic app server role loads a some custom values depending on the customer set previously.</p> <p>Note</p> <p>The <code>filter</code> renderer is not restricted to being used with salt-tower on the master only, it can be used on the minion and in custom states too.</p> <pre><code>#!yaml | filter pillar=site:customer\n# roles/appserver/customer_config.yaml\ncustomer_a:\n  worker_count: 4\n\ncustomer_b:\n  worker_count: 8\n</code></pre> <pre><code># tower.sls\nbase:\n  - *.customerA.example.org:\n      site:\n        customer: customer_a\n\n  - *.customerB.example.org:\n      site:\n        customer: customer_b\n\n  - appserver-*:\n      - roles/appserver.sls\n</code></pre> <pre><code># roles/appserver.sls\napplication:\n  install_dir: /opt/{{ tower.get(\"site:customer\") }}/\n  config: !include customer_config.yaml\n</code></pre> <p>This will result in the following output for minion <code>appserver-7.customerA.example.org</code>:</p> <pre><code>application:\n  install_dir: /opt/customer_a/\n  config:\n    worker_count: 4\n\nsite:\n  customer: customer_a\n</code></pre>"},{"location":"renderers/filter/#default-value","title":"Default value","text":"<p>If a grain or pillar doesn't exist, a default value can be given to match the top-level keys:</p> <pre><code>#!yaml | filter pillar=site:customer default=demo\n\ncustomer_a:\n  worker_count: 4\n\ncustomer_b:\n  worker_count: 8\n\ndemo:\n  worker_count: 1\n</code></pre>"},{"location":"renderers/filter/#wrapping-result-in-dictionary","title":"Wrapping result in dictionary","text":"<p>The result can be wrapping to a nested dictionary before being returned. It will be easier to customize a nested value for every minion, such as a user password:</p> <pre><code>#!yaml | filter grain=id key=users:root:password\n\nminion-a: $2b$05$BvTnTGxuWrMJJwty0mk2D.MCRTnBz4P9M3hZAnkxr0Eo1V9y8CJJK\nminion-b: $2b$05$4EaM70ZUcK4Y.oJe2ZC9FOuCz53WttNhD.NuipNUrxCodjDb6Cfg.\n</code></pre> <p>The returned data will look like this:</p> <pre><code>users:\n  root:\n    password: $2b$05$BvTnTGxuWrMJJwty0mk2D.MCRTnBz4P9M3hZAnkxr0Eo1V9y8CJJK\n</code></pre>"},{"location":"renderers/filter/#technical-details","title":"Technical details","text":""},{"location":"renderers/filter/#arguments","title":"Arguments","text":"<p>The <code>filter</code> renderer can take values from grains or the pillar, the key has to be specified on the shebang:</p> <pre><code>#!filter pillar=some:key\n</code></pre> <p>or</p> <pre><code>#!filter grain=os_family\n</code></pre> <p>A default value can be specified for both, if the grain or pillar key does not exist, the default value will be used for matching the top-level keys. The default value must be specified with quotes if it contains spaces.</p> <pre><code>#!filter pillar=some:key default=value\n#!filter grain=id default='value with space'\n</code></pre> <p>Note</p> <p>Arguments are parsed using Pythons <code>shlex.split</code>, therefore the usual shell-style escape rules apply to values.</p>"},{"location":"renderers/filter/#pattern-matching","title":"Pattern matching","text":"<p>Top-level keys are matched to the grain or pillar values using Pythons <code>fnmatch.fnmatch</code> function. Only the first matching item is returned, otherwise an empty dictionary.</p> <p>See <code>test/renderers/test_filter.py</code> for more examples and detailed behavior.</p>"},{"location":"renderers/text/","title":"Text","text":"<p>The <code>text</code> renderer converts an input into a string. This is needed to e.g. embed the result from the JINJA renderer into a text string, to be embedded into the pillar.</p> <p>The renderer further has options to strip leading and trailing whitespace.</p> <p>Note</p> <p>Read more about salts rendering pipeline and how to combine renderers in the official documentation.</p>"},{"location":"renderers/text/#example","title":"Example","text":""},{"location":"renderers/text/#strip-whitespace","title":"Strip whitespace","text":"<pre><code>#!jinja|text strip\n\n# role/webserver/files/nginx.default.j2\n# We want this file to be rendered using JINJA first, and into\n# a text string second, to be included as a string in the pillar.\n\nserver {\n    listen 80 default_server;\n    server_name {{ grains['localhost'] }};\n\n    root /var/www/html;\n}\n\n\n(Some newlines here)\n</code></pre> <p>This will render the template with JINJA and return the result as a text string. Leading and trailing whitespace will be stripped.</p> <pre><code># role/webserver/files/nginx.default.j2\n# We want this file to be rendered using JINJA first, and into\n# a text string second, to be included as a string in the pillar.\n\nserver {\n    listen 80 default_server;\n    server_name the-machine-hostname;\n\n    root /var/www/html;\n}\n</code></pre>"},{"location":"renderers/text/#nest-text-inside-a-dictionary","title":"Nest text inside a dictionary","text":"<p>In same case it might be needed or easier to have the renderer return the text in a (nested) dictionary, e.g. to be merged correctly into a specific pillar data file. The optional <code>key</code> arguments allows to give a \"path\" to nested the text inside a dict:</p> <pre><code>#!text key=nginx:site:default\n\nserver {\n    listen 80;\n    root /var/www/html;\n}\n</code></pre> <p>This will return the file as the following data structure:</p> <pre><code>nginx:\n  site:\n    default: |\n      server {\n          listen 80;\n          root /var/www/html;\n      }\n</code></pre>"},{"location":"renderers/text/#arguments","title":"Arguments","text":"<code>strip</code> Removes leading and trailing whitespace. <code>key=a:b:c</code> Nests the text string in a (nested) dictionary at the given path. <p>See <code>test/renderers/test_text.py</code> for more examples and detailed behavior.</p>"},{"location":"renderers/yamlet/","title":"Yamlet","text":"<p>The Yamlet renderer parses YAML and handles additional tags to work with files and blobs.</p> <p>Note</p> <p>salt-tower will default to use <code>jinja|yamlet</code> as the default renderer stack if the <code>yamlet</code> renderer is installed. You do not need to explicit set the renderer e.g. with <code>#!yamlet</code> to use its features in tower data files.</p>"},{"location":"renderers/yamlet/#yaml","title":"YAML","text":"<p>The Yamlet renderer parses a text file as YAML and returns the resulting data structure. The return value of this renderer therefore is a dict, or list, or similar, but not text.</p> <p>Additional YAML tags are processed to safely load and include files, e.g. text config files or binary files as blobs, without issues with YAML formatting or encoding compared to including them with JINJA.</p> <code>!include</code> Include a template file into the YAML data structure, e.g. a web server or application config file. <code>!read</code> Directly load and include a file without further processing. Can be a text or a binary file, e.g. a TLS private key or a binary license file. <p>See the following sections for details.</p>"},{"location":"renderers/yamlet/#examples","title":"Examples","text":""},{"location":"renderers/yamlet/#include-a-template-file","title":"Include a template file","text":"<p>The Yamlet renderer can include a template file into the pillar, without any formatting issues that might arrive when trying to use JINJA. The renderer will parse the YAML and directly render the template into the pillar, not the other way around.</p> <p>Assume we have an <code>nginx</code> state that expects a list of site configuration files as string blobs:</p> <pre><code># role/webserver/init.sls\n\nnginx:\n  site:\n    default: !include files/nginx.default.j2\n</code></pre> <pre><code>#!jinja|text\n# role/webserver/files/nginx.default.j2\n# We want this file to be rendered using JINJA first, and into\n# a text string second, to be included as a string in the pillar.\n\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    listen  443 ssl http2 default_server;\n    listen  [::]:443 ssl http2 default_server;\n\n    server_name {{ grains['localhost'] }};\n    include snippets/snakeoil.conf;\n\n    root /var/www/html;\n\n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ =404;\n    }\n}\n</code></pre> <p>The <code>!include</code> tag will render the file using the default salt renderers. You can therefore use JINJA or any other renderers. It is recommended to specify the renderers using a shebang as shown above:</p> <pre><code>#!jinja|text\n</code></pre> <p>This will first render the file using the JINJA, replacing e.g. <code>{{ grains['localhost'] }}</code>, and return the result as a text to the yamlet renderer.</p> <p>Note</p> <p>Read more about salts rendering pipeline and how to combine renderers in the official documentation.</p> <p>The result will look like this, but there will be no issue with indention, encoding, formatting or anything else:</p> <pre><code>nginx:\n  site:\n    default: |\n      # role/webserver/files/nginx.default.j2\n      # We want this file to be rendered using JINJA first, and into\n      # a text string second, to be included as a string in the pillar.\n\n      server {\n          listen 80 default_server;\n          listen [::]:80 default_server;\n\n          listen  443 ssl http2 default_server;\n          listen  [::]:443 ssl http2 default_server;\n\n          server_name server-hostname-here;\n          include snippets/snakeoil.conf;\n\n          root /var/www/html;\n\n          location / {\n              # First attempt to serve request as file, then\n              # as directory, then fall back to displaying a 404.\n              try_files $uri $uri/ =404;\n          }\n      }\n</code></pre> <p>This can greatly simplify writing states, as is much easier to just ship full configuration files or snippets.</p>"},{"location":"renderers/yamlet/#custom-template-context","title":"Custom template context","text":"<p>The longer mapping variant of the <code>!include</code> tag allows passing custom context data to the renderers. This can be used to expand e.g. a shared configuration file snippet with some custom values:</p> <pre><code># role/webserver/init.sls\n\nnginx:\n  site:\n    app1: !include\n      source: files/nginx.app.j2\n      context:\n        server_name: app1.com\n        directory: sites/app1\n\n    app2: !include\n      source: files/nginx.app.j2\n      context:\n        server_name: app2.com\n        directory: app2/public\n</code></pre> <pre><code>#!jinja|text\n# role/webserver/files/nginx.app.j2\n\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    server_name {{ server_name }};\n\n    root /var/www/{{ directory }};\n\n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ =404;\n    }\n}\n</code></pre>"},{"location":"renderers/yamlet/#include-a-data-file","title":"Include a data file","text":"<p>The result of a template file doesn't have to a string, it can be data too. You can e.g. include one YAML file into multiple pillar files, or combine that with the filter renderer, to include data from a shared set.</p> <p>The following example shows to include a shared YAML dataset into multiple places, without any parsing or indention errors, as can happen when using the JINJA <code>include</code> directive:</p> <pre><code>#!yaml\n# Shared data set (dataset.yaml)\n\nkey: 1\n</code></pre> <pre><code># A pillar data file\napplication_1:\n  config: !include ../dataset.yaml\n\napplication_2:\n  config: !include ../dataset.yaml\n</code></pre> <p>The result will have the data set loaded and included for both application keys:</p> <pre><code>application_1:\n  config:\n    key: 1\n\napplication_2:\n  config:\n    key: 2\n</code></pre>"},{"location":"renderers/yamlet/#include-a-binary-file","title":"Include a binary file","text":"<p>The <code>!read</code> YAML tag can safely load text or binary files and include them as blobs in the result.</p> <pre><code>application:\n  license_file: !read files/license.bin\n</code></pre> <p>The <code>license.bin</code> file can be any kind of file, even a binary file. The Yamlet renderer will load the file after it has parsed the YAML and safely embed the binary file content into the data result.</p> <p>Note</p> <p>The resulting data structure will include file content as binary string, not a Unicode string as everything else, e.g.:</p> <pre><code>pillar['key'] == b\"jd\\x81\\xed\\xa2~*\\xca6\\xd88,\\x15zr\\xb6\"\n</code></pre> <p>Salt internal and most states (e.g. <code>file.managed</code>) should have not problem with that, but custom code might need adjustments if it e.g. processes the content and did not expect a binary string.</p>"},{"location":"renderers/yamlet/#tag-details","title":"Tag details","text":""},{"location":"renderers/yamlet/#include","title":"include","text":"<p>The <code>!include</code> tag can be used the short variant, to include a template file using the default renderers:</p> <pre><code>key: !include path/to/template\n</code></pre> <p>The tag also takes a mapping, which allows specifying more options:</p> <pre><code>key: !include\n  # Path to template file\n  source: path/to/template\n\n  # Default renderers if not shebang is specified in template file\n  default: jinja|yamlet\n\n  # Additional context passed to renderers\n  context:\n    some_data:\n      key: 1\n</code></pre>"},{"location":"renderers/yamlet/#read","title":"read","text":"<p>The <code>!read</code> only supports the show variant and as no options:</p> <pre><code>key: !read path/to/file\n</code></pre> <p>See <code>test/renderers/test_yamlet.py</code> for more examples and detailed behavior.</p>"}]}
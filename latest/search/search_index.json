{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Salt Tower \u2014 A Flexible External Pillar Module \u00b6 Salt Tower is an advanced and flexible ext_pillar that gives access to pillar values while processing and merging them, can render all usual salt file formats and include private and binary files for a minion. Salt Tower is inspired by pillarstack for merging pillar files and giving access to them. It also has a top file like salt itself and utilizes salt renderers to supports all formats such as YAML, Jinja, Python and any combination. Supercharged renderers for plain text and YAML are included too. Each tower data file is passed the current processed pillars. They can therefore access previously defined values. Data files can include other files that are all merged together. Salt Tower is designed to completely replace the usual pillar repository or can be utilized beside salts original pillar that e.g. can bootstrap a salt master with Salt Tower.","title":"README"},{"location":"#salt-tower-a-flexible-external-pillar-module","text":"Salt Tower is an advanced and flexible ext_pillar that gives access to pillar values while processing and merging them, can render all usual salt file formats and include private and binary files for a minion. Salt Tower is inspired by pillarstack for merging pillar files and giving access to them. It also has a top file like salt itself and utilizes salt renderers to supports all formats such as YAML, Jinja, Python and any combination. Supercharged renderers for plain text and YAML are included too. Each tower data file is passed the current processed pillars. They can therefore access previously defined values. Data files can include other files that are all merged together. Salt Tower is designed to completely replace the usual pillar repository or can be utilized beside salts original pillar that e.g. can bootstrap a salt master with Salt Tower.","title":"Salt Tower \u2014 A Flexible External Pillar Module"},{"location":"renderers/yamlet/","text":"Yamlet \u00b6 The Yamlet renderer parses YAML and handles additional tags to work with files and blobs. Note salt-tower will default to use jinja|yamlet as the default renderer stack if the yamlet renderer is installed. You do not need to explicit set the renderer e.g. with #!yamlet . Include a template file \u00b6 The Yamlet renderer can include a template file into the pillar, without any formatting issues that might arrive when trying to use JINJA. The renderer will parse the YAML and directly render the template into the pillar, not the other way around. The template file will be rendered Assume we have an nginx state that expects a list of site configuration files as string blobs: # role/webserver/init.sls nginx : site : default : !include files/nginx.default.j2 #!jinja|text # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name {{ grains [ 'localhost' ] }} ; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } The !include tag will","title":"Yamlet"},{"location":"renderers/yamlet/#yamlet","text":"The Yamlet renderer parses YAML and handles additional tags to work with files and blobs. Note salt-tower will default to use jinja|yamlet as the default renderer stack if the yamlet renderer is installed. You do not need to explicit set the renderer e.g. with #!yamlet .","title":"Yamlet"},{"location":"renderers/yamlet/#include-a-template-file","text":"The Yamlet renderer can include a template file into the pillar, without any formatting issues that might arrive when trying to use JINJA. The renderer will parse the YAML and directly render the template into the pillar, not the other way around. The template file will be rendered Assume we have an nginx state that expects a list of site configuration files as string blobs: # role/webserver/init.sls nginx : site : default : !include files/nginx.default.j2 #!jinja|text # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name {{ grains [ 'localhost' ] }} ; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } The !include tag will","title":"Include a template file"}]}
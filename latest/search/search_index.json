{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Salt Tower \u2014 A Flexible External Pillar Module \u00b6 Salt Tower is an advanced and flexible external pillar module that gives access to pillar values while processing and merging them, can render all usual salt file formats and include private and binary files for a minion. Salt Tower is inspired by pillarstack for merging pillar files and giving access to them. It also has a top file like salt itself and utilizes salt renderers to supports all formats such as YAML, JINJA, Python and any combination. Supercharged renderers for plain text and YAML are included too. Each tower data file is passed the current processed pillars. They can therefore access previously defined values. Data files can include other files that are all merged together. Salt Tower is designed to completely replace the usual pillar repository or can be utilized beside salts original pillar that e.g. can bootstrap a salt master with Salt Tower.","title":"Welcome"},{"location":"#salt-tower-a-flexible-external-pillar-module","text":"Salt Tower is an advanced and flexible external pillar module that gives access to pillar values while processing and merging them, can render all usual salt file formats and include private and binary files for a minion. Salt Tower is inspired by pillarstack for merging pillar files and giving access to them. It also has a top file like salt itself and utilizes salt renderers to supports all formats such as YAML, JINJA, Python and any combination. Supercharged renderers for plain text and YAML are included too. Each tower data file is passed the current processed pillars. They can therefore access previously defined values. Data files can include other files that are all merged together. Salt Tower is designed to completely replace the usual pillar repository or can be utilized beside salts original pillar that e.g. can bootstrap a salt master with Salt Tower.","title":"Salt Tower \u2014 A Flexible External Pillar Module"},{"location":"10-installation/","text":"Installation \u00b6 Salt Tower needs to be installed on the salt master to be available as an ext_pillar module. The recommended installation methods are either via salts gitfs backend or with Pythons package manager pip . Salt GitFS \u00b6 This method utilizes salts gitfs backend to directly load the tower module and renderers from this git repository. Ensure to follow the gitfs setup guide . Add the following to you salt master configuration, e.g. /etc/salt/master.d/tower.conf . It is recommended to pin to a specific version or commit, to avoid unexpected updates and because you need to sync all modules after any change. gitfs_remotes : - https://github.com/jgraichen/salt-tower.git : - base : v1.7.0 You need to sync all salt modules after installation and any upgrade: $ salt-run saltutil.sync_all pillar: - pillar.tower renderers: - renderers.filter - renderers.text - renderers.yamlet This will make all modules (e.g. renderers) available to all minions too. Warning All content from this repository will be \"loaded\" into your states tree, including any files from e.g. test/ , examples/ , docs/ or the root directory. PIP Python Package \u00b6 Salt Tower can be installed via the pip Python package manager too: $ pip install salt-tower This will install Salt Tower as a Python package on the system, which is loaded by the salt processes. Warning The tower modules (e.g. renderers) will only be available on the salt master or minion where the salt-tower package is installed. They are not automatically synced to any minion.","title":"Installation"},{"location":"10-installation/#installation","text":"Salt Tower needs to be installed on the salt master to be available as an ext_pillar module. The recommended installation methods are either via salts gitfs backend or with Pythons package manager pip .","title":"Installation"},{"location":"10-installation/#salt-gitfs","text":"This method utilizes salts gitfs backend to directly load the tower module and renderers from this git repository. Ensure to follow the gitfs setup guide . Add the following to you salt master configuration, e.g. /etc/salt/master.d/tower.conf . It is recommended to pin to a specific version or commit, to avoid unexpected updates and because you need to sync all modules after any change. gitfs_remotes : - https://github.com/jgraichen/salt-tower.git : - base : v1.7.0 You need to sync all salt modules after installation and any upgrade: $ salt-run saltutil.sync_all pillar: - pillar.tower renderers: - renderers.filter - renderers.text - renderers.yamlet This will make all modules (e.g. renderers) available to all minions too. Warning All content from this repository will be \"loaded\" into your states tree, including any files from e.g. test/ , examples/ , docs/ or the root directory.","title":"Salt GitFS"},{"location":"10-installation/#pip-python-package","text":"Salt Tower can be installed via the pip Python package manager too: $ pip install salt-tower This will install Salt Tower as a Python package on the system, which is loaded by the salt processes. Warning The tower modules (e.g. renderers) will only be available on the salt master or minion where the salt-tower package is installed. They are not automatically synced to any minion.","title":"PIP Python Package"},{"location":"20-configuration/","text":"Configuration \u00b6 Salt Tower is set up and configured in the salt master configuration. See salts ext_pillar documentation for details about external pillar modules. The tower external pillar modules only needs one or more tower files for configuration: # /etc/salt/master.d/tower.conf ext_pillar : - tower : /path/to/tower.sls","title":"Configuration"},{"location":"20-configuration/#configuration","text":"Salt Tower is set up and configured in the salt master configuration. See salts ext_pillar documentation for details about external pillar modules. The tower external pillar modules only needs one or more tower files for configuration: # /etc/salt/master.d/tower.conf ext_pillar : - tower : /path/to/tower.sls","title":"Configuration"},{"location":"30-tower-file/","text":"Tower File \u00b6 The tower files works similar to the regular top.sls . It defines rules which files shall be loaded for a minion, based on e.g. the minion ID, grains, or pillar values. Example \u00b6 base : # salt environment # Load common pillar data files for all minions. - common/*.sls # Use JINJA to load some pillar data files based on # some grains, e.g. operating system. - dist/{{ grains[\"oscodename\"] }}/*.sls # Match a minion by ID - \"*.example.org\" : # Include a pillar data file for this minion. Path is # relative to the tower.sls. - roles/example.sls # Directly set some pillar values without loading # an extra file first. - site : domain : example.org # Match a previously set pillar value - \"I@site:domain:example.org\" : - site/example/*.sls","title":"Tower File"},{"location":"30-tower-file/#tower-file","text":"The tower files works similar to the regular top.sls . It defines rules which files shall be loaded for a minion, based on e.g. the minion ID, grains, or pillar values.","title":"Tower File"},{"location":"30-tower-file/#example","text":"base : # salt environment # Load common pillar data files for all minions. - common/*.sls # Use JINJA to load some pillar data files based on # some grains, e.g. operating system. - dist/{{ grains[\"oscodename\"] }}/*.sls # Match a minion by ID - \"*.example.org\" : # Include a pillar data file for this minion. Path is # relative to the tower.sls. - roles/example.sls # Directly set some pillar values without loading # an extra file first. - site : domain : example.org # Match a previously set pillar value - \"I@site:domain:example.org\" : - site/example/*.sls","title":"Example"},{"location":"40-pillar-data-file/","text":"Pillar Data File \u00b6 Pillar data files define the actual pillar data that is loaded and merged by salt tower. Data files are rendered using the available salt renderers, therefore all usual features are available. The default renderers are jinja|yamlet , if no shebang is specified. Example \u00b6 include : - shared/wordpress states : - nginx - php-fpm nginx : package : nginx-light sites : blog : !include files/nginx.blog.j2 { % if grains [ \"oscodename\" ] == \"bionic\" % } default : !read files/nginx.default-override.conf { % endif % } wordpress : config : title : Blog for {{ tower.get(\"site:customer_name\") }}","title":"Pillar Data File"},{"location":"40-pillar-data-file/#pillar-data-file","text":"Pillar data files define the actual pillar data that is loaded and merged by salt tower. Data files are rendered using the available salt renderers, therefore all usual features are available. The default renderers are jinja|yamlet , if no shebang is specified.","title":"Pillar Data File"},{"location":"40-pillar-data-file/#example","text":"include : - shared/wordpress states : - nginx - php-fpm nginx : package : nginx-light sites : blog : !include files/nginx.blog.j2 { % if grains [ \"oscodename\" ] == \"bionic\" % } default : !read files/nginx.default-override.conf { % endif % } wordpress : config : title : Blog for {{ tower.get(\"site:customer_name\") }}","title":"Example"},{"location":"renderers/","text":"Renderers \u00b6 Salt-tower ships multiple renderers to ease working with complex pillars and organizaing data. Yamlet \u00b6 The Yamlet renderer is a supercharged YAML renderer that supports including additional files, template or binary files, in a safe and easy manner. This can help with shipping configuration files or snippet, license blobs, private files such as TLS keys, securely from the pillar to minions, sharing templates on the master to ship ready to use config files to minions, organize and share pillar data between minions, working with complex setups, such as multiple customers and brands, writing simpler states by just dropping config files blobs instead of thousand lines of JINJA macros. Filter \u00b6 The filter renderer returns a subset of its data matching grains or pillar keys. This eases organizing data and reusing datasets for multiple minions, roles or any common pillar file. Text \u00b6 The text renderer is a renderer mostly needed in conjunction with the Yamlet renderer when loading and including templates.","title":"Introduction"},{"location":"renderers/#renderers","text":"Salt-tower ships multiple renderers to ease working with complex pillars and organizaing data.","title":"Renderers"},{"location":"renderers/#yamlet","text":"The Yamlet renderer is a supercharged YAML renderer that supports including additional files, template or binary files, in a safe and easy manner. This can help with shipping configuration files or snippet, license blobs, private files such as TLS keys, securely from the pillar to minions, sharing templates on the master to ship ready to use config files to minions, organize and share pillar data between minions, working with complex setups, such as multiple customers and brands, writing simpler states by just dropping config files blobs instead of thousand lines of JINJA macros.","title":"Yamlet"},{"location":"renderers/#filter","text":"The filter renderer returns a subset of its data matching grains or pillar keys. This eases organizing data and reusing datasets for multiple minions, roles or any common pillar file.","title":"Filter"},{"location":"renderers/#text","text":"The text renderer is a renderer mostly needed in conjunction with the Yamlet renderer when loading and including templates.","title":"Text"},{"location":"renderers/filter/","text":"Filter \u00b6 The filter renderer takes a data structure, e.g. from the Yamlet renderer, applies some filter based on the top-level keys and returns the first matching item. Example \u00b6 By default, the filter renderer will match top-level keys with the salt minion ID from grains, but any grain can be specified: Minion ID \u00b6 #!yaml|filter grain=id web_* : roles : - webserver db_* : roles : - database salt : roles : - salt/master *.example.org : roles : - app This example matches each top-level key with the id grain (the minion ID) and only returns the first matching data: # minion: web_03.example.org roles : - webserver # minion: db_a.example.org roles : - database # minion: blog.example.org roles : - app Match a grain \u00b6 The renderer can use any grain to match top-level keys: #!yaml | filter grain=os_family Debian : repo_url : http://apt.example.org RedHat : repo_url : http://rpm.example.org Match a pillar key \u00b6 The filter renderer can match on a previously set pillar key too. In this example the generic app server role loads a some custom values depending on the customer set previously. Note The filter renderer is not restricted to being used with salt-tower on the master only, it can be used on the minion and in custom states too. #!yaml | filter pillar=site:customer # roles/appserver/customer_config.yaml customer_a : worker_count : 4 customer_b : worker_count : 8 # tower.sls base : - *.customerA.example.org : site : customer : customer_a - *.customerB.example.org : site : customer : customer_b - appserver-* : - roles/appserver.sls # roles/appserver.sls application : install_dir : /opt/{{ tower.get(\"site:customer\") }}/ config : !include customer_config.yaml This will result in the following output for minion appserver-7.customerA.example.org : application : install_dir : /opt/customer_a/ config : worker_count : 4 site : customer : customer_a Default value \u00b6 If a grain or pillar doesn't exist, a default value can be given to match the top-level keys: #!yaml | filter pillar=site:customer default=demo customer_a : worker_count : 4 customer_b : worker_count : 8 demo : worker_count : 1 Technical details \u00b6 Arguments \u00b6 The filter renderer can take values from grains or the pillar, the key has to be specified on the shebang: #!filter pillar=some:key or #!filter grain=os_family A default value can be specified for both, if the grain or pillar key does not exist, the default value will be used for matching the top-level keys. The default value must be specified with quotes if it contains spaces. #!filter pillar=some:key default=value #!filter grain=id default='value with space' Note Arguments are parsed using Pythons shlex.split , therefore the usual shell-style escape rules apply to values. Pattern matching \u00b6 Top-level keys are matched to the grain or pillar values using Pythons fnmatch.fnmatch function. Only the first matching item is returned, otherwise an empty dictionary. See test/renderers/test_filter.py for more examples and detailed behavior.","title":"Filter"},{"location":"renderers/filter/#filter","text":"The filter renderer takes a data structure, e.g. from the Yamlet renderer, applies some filter based on the top-level keys and returns the first matching item.","title":"Filter"},{"location":"renderers/filter/#example","text":"By default, the filter renderer will match top-level keys with the salt minion ID from grains, but any grain can be specified:","title":"Example"},{"location":"renderers/filter/#minion-id","text":"#!yaml|filter grain=id web_* : roles : - webserver db_* : roles : - database salt : roles : - salt/master *.example.org : roles : - app This example matches each top-level key with the id grain (the minion ID) and only returns the first matching data: # minion: web_03.example.org roles : - webserver # minion: db_a.example.org roles : - database # minion: blog.example.org roles : - app","title":"Minion ID"},{"location":"renderers/filter/#match-a-grain","text":"The renderer can use any grain to match top-level keys: #!yaml | filter grain=os_family Debian : repo_url : http://apt.example.org RedHat : repo_url : http://rpm.example.org","title":"Match a grain"},{"location":"renderers/filter/#match-a-pillar-key","text":"The filter renderer can match on a previously set pillar key too. In this example the generic app server role loads a some custom values depending on the customer set previously. Note The filter renderer is not restricted to being used with salt-tower on the master only, it can be used on the minion and in custom states too. #!yaml | filter pillar=site:customer # roles/appserver/customer_config.yaml customer_a : worker_count : 4 customer_b : worker_count : 8 # tower.sls base : - *.customerA.example.org : site : customer : customer_a - *.customerB.example.org : site : customer : customer_b - appserver-* : - roles/appserver.sls # roles/appserver.sls application : install_dir : /opt/{{ tower.get(\"site:customer\") }}/ config : !include customer_config.yaml This will result in the following output for minion appserver-7.customerA.example.org : application : install_dir : /opt/customer_a/ config : worker_count : 4 site : customer : customer_a","title":"Match a pillar key"},{"location":"renderers/filter/#default-value","text":"If a grain or pillar doesn't exist, a default value can be given to match the top-level keys: #!yaml | filter pillar=site:customer default=demo customer_a : worker_count : 4 customer_b : worker_count : 8 demo : worker_count : 1","title":"Default value"},{"location":"renderers/filter/#technical-details","text":"","title":"Technical details"},{"location":"renderers/filter/#arguments","text":"The filter renderer can take values from grains or the pillar, the key has to be specified on the shebang: #!filter pillar=some:key or #!filter grain=os_family A default value can be specified for both, if the grain or pillar key does not exist, the default value will be used for matching the top-level keys. The default value must be specified with quotes if it contains spaces. #!filter pillar=some:key default=value #!filter grain=id default='value with space' Note Arguments are parsed using Pythons shlex.split , therefore the usual shell-style escape rules apply to values.","title":"Arguments"},{"location":"renderers/filter/#pattern-matching","text":"Top-level keys are matched to the grain or pillar values using Pythons fnmatch.fnmatch function. Only the first matching item is returned, otherwise an empty dictionary. See test/renderers/test_filter.py for more examples and detailed behavior.","title":"Pattern matching"},{"location":"renderers/text/","text":"Text \u00b6 The text renderer converts an input into a string. This is needed to e.g. embed the result from the JINJA renderer into a text string, to be embedded into the pillar. The renderer further has options to strip leading and trailing whitespace. Note Read more about salts rendering pipeline and how to combine renderers in the official documentation . Example \u00b6 Strip whitespace \u00b6 #!jinja|text strip # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; server_name {{ grains [ 'localhost' ] }} ; root /var/www/html; } (Some newlines here) This will render the template with JINJA and return the result as a text string. Leading and trailing whitespace will be stripped. # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; server_name the-machine-hostname; root /var/www/html; } Nest text inside a dictionary \u00b6 In same case it might be needed or easier to have the renderer return the text in a (nested) dictionary, e.g. to be merged correctly into a specific pillar data file. The optional key arguments allows to give a \"path\" to nested the text inside a dict: #!text key=nginx:site:default server { listen 80; root /var/www/html; } This will return the file as the following data structure: nginx : site : default : | server { listen 80; root /var/www/html; } Arguments \u00b6 strip Removes leading and trailing whitespace. key=a:b:c Nests the text string in a (nested) dictionary at the given path. See test/renderers/test_text.py for more examples and detailed behavior.","title":"Text"},{"location":"renderers/text/#text","text":"The text renderer converts an input into a string. This is needed to e.g. embed the result from the JINJA renderer into a text string, to be embedded into the pillar. The renderer further has options to strip leading and trailing whitespace. Note Read more about salts rendering pipeline and how to combine renderers in the official documentation .","title":"Text"},{"location":"renderers/text/#example","text":"","title":"Example"},{"location":"renderers/text/#strip-whitespace","text":"#!jinja|text strip # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; server_name {{ grains [ 'localhost' ] }} ; root /var/www/html; } (Some newlines here) This will render the template with JINJA and return the result as a text string. Leading and trailing whitespace will be stripped. # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; server_name the-machine-hostname; root /var/www/html; }","title":"Strip whitespace"},{"location":"renderers/text/#nest-text-inside-a-dictionary","text":"In same case it might be needed or easier to have the renderer return the text in a (nested) dictionary, e.g. to be merged correctly into a specific pillar data file. The optional key arguments allows to give a \"path\" to nested the text inside a dict: #!text key=nginx:site:default server { listen 80; root /var/www/html; } This will return the file as the following data structure: nginx : site : default : | server { listen 80; root /var/www/html; }","title":"Nest text inside a dictionary"},{"location":"renderers/text/#arguments","text":"strip Removes leading and trailing whitespace. key=a:b:c Nests the text string in a (nested) dictionary at the given path. See test/renderers/test_text.py for more examples and detailed behavior.","title":"Arguments"},{"location":"renderers/yamlet/","text":"Yamlet \u00b6 The Yamlet renderer parses YAML and handles additional tags to work with files and blobs. Note salt-tower will default to use jinja|yamlet as the default renderer stack if the yamlet renderer is installed. You do not need to explicit set the renderer e.g. with #!yamlet to use its features in tower data files. YAML \u00b6 The Yamlet renderer parses a text file as YAML and returns the resulting data structure. The return value of this renderer therefore is a dict, or list, or similar, but not text. Additional YAML tags are processed to safely load and include files, e.g. text config files or binary files as blobs, without issues with YAML formatting or encoding compared to including them with JINJA. !include Include a template file into the YAML data structure, e.g. a web server or application config file. !read Directly load and include a file without further processing. Can be a text or a binary file, e.g. a TLS private key or a binary license file. See the following sections for details. Examples \u00b6 Include a template file \u00b6 The Yamlet renderer can include a template file into the pillar, without any formatting issues that might arrive when trying to use JINJA. The renderer will parse the YAML and directly render the template into the pillar, not the other way around. Assume we have an nginx state that expects a list of site configuration files as string blobs: # role/webserver/init.sls nginx : site : default : !include files/nginx.default.j2 #!jinja|text # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name {{ grains [ 'localhost' ] }} ; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } The !include tag will render the file using the default salt renderers. You can therefore use JINJA or any other renderers. It is recommended to specify the renderers using a shebang as shown above: #!jinja|text This will first render the file using the JINJA, replacing e.g. {{ grains [ 'localhost' ] }} , and return the result as a text to the yamlet renderer. Note Read more about salts rendering pipeline and how to combine renderers in the official documentation . The result will look like this, but there will be no issue with indention, encoding, formatting or anything else: nginx : site : default : | # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name server-hostname-here; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } This can greatly simplify writing states, as is much easier to just ship full configuration files or snippets. Custom template context \u00b6 The longer mapping variant of the !include tag allows passing custom context data to the renderers. This can be used to expand e.g. a shared configuration file snippet with some custom values: # role/webserver/init.sls nginx : site : app1 : !include source : files/nginx.app.j2 context : server_name : app1.com directory : sites/app1 app2 : !include source : files/nginx.app.j2 context : server_name : app2.com directory : app2/public #!jinja|text # role/webserver/files/nginx.app.j2 server { listen 80 default_server; listen [::]:80 default_server; server_name {{ server_name }} ; root /var/www/ {{ directory }} ; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } Include a data file \u00b6 The result of a template file doesn't have to a string, it can be data too. You can e.g. include one YAML file into multiple pillar files, or combine that with the filter renderer , to include data from a shared set. The following example shows to include a shared YAML dataset into multiple places, without any parsing or indention errors, as can happen when using the JINJA include directive: #!yaml # Shared data set (dataset.yaml) key : 1 # A pillar data file application_1 : config : !include ../dataset.yaml application_2 : config : !include ../dataset.yaml The result will have the data set loaded and included for both application keys: application_1 : config : key : 1 application_2 : config : key : 2 Include a binary file \u00b6 The !read YAML tag can safely load text or binary files and include them as blobs in the result. application : license_file : !read files/license.bin The license.bin file can be any kind of file, even a binary file. The Yamlet renderer will load the file after it has parsed the YAML and safely embed the binary file content into the data result. Note The resulting data structure will include file content as binary string, not a Unicode string as everything else, e.g.: pillar [ 'key' ] == b \"jd \\x81\\xed\\xa2 ~* \\xca 6 \\xd8 8, \\x15 zr \\xb6 \" Salt internal and most states (e.g. file.managed ) should have not problem with that, but custom code might need adjustments if it e.g. processes the content and did not expect a binary string. Tag details \u00b6 include \u00b6 The !include tag can be used the short variant, to include a template file using the default renderers: key : !include path/to/template The tag also takes a mapping, which allows specifying more options: key : !include # Path to template file source : path/to/template # Default renderers if not shebang is specified in template file default : jinja|yamlet # Additional context passed to renderers context : some_data : key : 1 read \u00b6 The !read only supports the show variant and as no options: key : !read path/to/file See test/renderers/test_yamlet.py for more examples and detailed behavior.","title":"Yamlet"},{"location":"renderers/yamlet/#yamlet","text":"The Yamlet renderer parses YAML and handles additional tags to work with files and blobs. Note salt-tower will default to use jinja|yamlet as the default renderer stack if the yamlet renderer is installed. You do not need to explicit set the renderer e.g. with #!yamlet to use its features in tower data files.","title":"Yamlet"},{"location":"renderers/yamlet/#yaml","text":"The Yamlet renderer parses a text file as YAML and returns the resulting data structure. The return value of this renderer therefore is a dict, or list, or similar, but not text. Additional YAML tags are processed to safely load and include files, e.g. text config files or binary files as blobs, without issues with YAML formatting or encoding compared to including them with JINJA. !include Include a template file into the YAML data structure, e.g. a web server or application config file. !read Directly load and include a file without further processing. Can be a text or a binary file, e.g. a TLS private key or a binary license file. See the following sections for details.","title":"YAML"},{"location":"renderers/yamlet/#examples","text":"","title":"Examples"},{"location":"renderers/yamlet/#include-a-template-file","text":"The Yamlet renderer can include a template file into the pillar, without any formatting issues that might arrive when trying to use JINJA. The renderer will parse the YAML and directly render the template into the pillar, not the other way around. Assume we have an nginx state that expects a list of site configuration files as string blobs: # role/webserver/init.sls nginx : site : default : !include files/nginx.default.j2 #!jinja|text # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name {{ grains [ 'localhost' ] }} ; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } The !include tag will render the file using the default salt renderers. You can therefore use JINJA or any other renderers. It is recommended to specify the renderers using a shebang as shown above: #!jinja|text This will first render the file using the JINJA, replacing e.g. {{ grains [ 'localhost' ] }} , and return the result as a text to the yamlet renderer. Note Read more about salts rendering pipeline and how to combine renderers in the official documentation . The result will look like this, but there will be no issue with indention, encoding, formatting or anything else: nginx : site : default : | # role/webserver/files/nginx.default.j2 # We want this file to be rendered using JINJA first, and into # a text string second, to be included as a string in the pillar. server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name server-hostname-here; include snippets/snakeoil.conf; root /var/www/html; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } } This can greatly simplify writing states, as is much easier to just ship full configuration files or snippets.","title":"Include a template file"},{"location":"renderers/yamlet/#custom-template-context","text":"The longer mapping variant of the !include tag allows passing custom context data to the renderers. This can be used to expand e.g. a shared configuration file snippet with some custom values: # role/webserver/init.sls nginx : site : app1 : !include source : files/nginx.app.j2 context : server_name : app1.com directory : sites/app1 app2 : !include source : files/nginx.app.j2 context : server_name : app2.com directory : app2/public #!jinja|text # role/webserver/files/nginx.app.j2 server { listen 80 default_server; listen [::]:80 default_server; server_name {{ server_name }} ; root /var/www/ {{ directory }} ; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } }","title":"Custom template context"},{"location":"renderers/yamlet/#include-a-data-file","text":"The result of a template file doesn't have to a string, it can be data too. You can e.g. include one YAML file into multiple pillar files, or combine that with the filter renderer , to include data from a shared set. The following example shows to include a shared YAML dataset into multiple places, without any parsing or indention errors, as can happen when using the JINJA include directive: #!yaml # Shared data set (dataset.yaml) key : 1 # A pillar data file application_1 : config : !include ../dataset.yaml application_2 : config : !include ../dataset.yaml The result will have the data set loaded and included for both application keys: application_1 : config : key : 1 application_2 : config : key : 2","title":"Include a data file"},{"location":"renderers/yamlet/#include-a-binary-file","text":"The !read YAML tag can safely load text or binary files and include them as blobs in the result. application : license_file : !read files/license.bin The license.bin file can be any kind of file, even a binary file. The Yamlet renderer will load the file after it has parsed the YAML and safely embed the binary file content into the data result. Note The resulting data structure will include file content as binary string, not a Unicode string as everything else, e.g.: pillar [ 'key' ] == b \"jd \\x81\\xed\\xa2 ~* \\xca 6 \\xd8 8, \\x15 zr \\xb6 \" Salt internal and most states (e.g. file.managed ) should have not problem with that, but custom code might need adjustments if it e.g. processes the content and did not expect a binary string.","title":"Include a binary file"},{"location":"renderers/yamlet/#tag-details","text":"","title":"Tag details"},{"location":"renderers/yamlet/#include","text":"The !include tag can be used the short variant, to include a template file using the default renderers: key : !include path/to/template The tag also takes a mapping, which allows specifying more options: key : !include # Path to template file source : path/to/template # Default renderers if not shebang is specified in template file default : jinja|yamlet # Additional context passed to renderers context : some_data : key : 1","title":"include"},{"location":"renderers/yamlet/#read","text":"The !read only supports the show variant and as no options: key : !read path/to/file See test/renderers/test_yamlet.py for more examples and detailed behavior.","title":"read"}]}